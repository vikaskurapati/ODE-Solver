struct typedef __va_list_tag __va_list_tag {
	unsigned int               gp_offset;            /*     0     4 */
	unsigned int               fp_offset;            /*     4     4 */
	void *                     overflow_arg_area;    /*     8     8 */
	void *                     reg_save_area;        /*    16     8 */

	/* size: 24, cachelines: 1, members: 4 */
	/* last cacheline: 24 bytes */
};
struct _IO_FILE {
	int                        _flags;               /*     0     4 */

	/* XXX 4 bytes hole, try to pack */

	char *                     _IO_read_ptr;         /*     8     8 */
	char *                     _IO_read_end;         /*    16     8 */
	char *                     _IO_read_base;        /*    24     8 */
	char *                     _IO_write_base;       /*    32     8 */
	char *                     _IO_write_ptr;        /*    40     8 */
	char *                     _IO_write_end;        /*    48     8 */
	char *                     _IO_buf_base;         /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	char *                     _IO_buf_end;          /*    64     8 */
	char *                     _IO_save_base;        /*    72     8 */
	char *                     _IO_backup_base;      /*    80     8 */
	char *                     _IO_save_end;         /*    88     8 */
	class _IO_marker *         _markers;             /*    96     8 */
	class _IO_FILE *           _chain;               /*   104     8 */
	int                        _fileno;              /*   112     4 */
	int                        _flags2;              /*   116     4 */
	__off_t                    _old_offset;          /*   120     8 */
	/* --- cacheline 2 boundary (128 bytes) --- */
	short unsigned int         _cur_column;          /*   128     2 */
	signed char                _vtable_offset;       /*   130     1 */
	char                       _shortbuf[1];         /*   131     1 */

	/* XXX 4 bytes hole, try to pack */

	_IO_lock_t *               _lock;                /*   136     8 */
	__off64_t                  _offset;              /*   144     8 */
	class _IO_codecvt *        _codecvt;             /*   152     8 */
	class _IO_wide_data *      _wide_data;           /*   160     8 */
	class _IO_FILE *           _freeres_list;        /*   168     8 */
	void *                     _freeres_buf;         /*   176     8 */
	size_t                     __pad5;               /*   184     8 */
	/* --- cacheline 3 boundary (192 bytes) --- */
	int                        _mode;                /*   192     4 */
	char                       _unused2[20];         /*   196    20 */

	/* size: 216, cachelines: 4, members: 29 */
	/* sum members: 208, holes: 2, sum holes: 8 */
	/* last cacheline: 24 bytes */
};
struct tm {
	int                        tm_sec;               /*     0     4 */
	int                        tm_min;               /*     4     4 */
	int                        tm_hour;              /*     8     4 */
	int                        tm_mday;              /*    12     4 */
	int                        tm_mon;               /*    16     4 */
	int                        tm_year;              /*    20     4 */
	int                        tm_wday;              /*    24     4 */
	int                        tm_yday;              /*    28     4 */
	int                        tm_isdst;             /*    32     4 */

	/* XXX 4 bytes hole, try to pack */

	long int                   tm_gmtoff;            /*    40     8 */
	const char  *              tm_zone;              /*    48     8 */

	/* size: 56, cachelines: 1, members: 11 */
	/* sum members: 52, holes: 1, sum holes: 4 */
	/* last cacheline: 56 bytes */
};
struct lconv {
	char *                     decimal_point;        /*     0     8 */
	char *                     thousands_sep;        /*     8     8 */
	char *                     grouping;             /*    16     8 */
	char *                     int_curr_symbol;      /*    24     8 */
	char *                     currency_symbol;      /*    32     8 */
	char *                     mon_decimal_point;    /*    40     8 */
	char *                     mon_thousands_sep;    /*    48     8 */
	char *                     mon_grouping;         /*    56     8 */
	/* --- cacheline 1 boundary (64 bytes) --- */
	char *                     positive_sign;        /*    64     8 */
	char *                     negative_sign;        /*    72     8 */
	char                       int_frac_digits;      /*    80     1 */
	char                       frac_digits;          /*    81     1 */
	char                       p_cs_precedes;        /*    82     1 */
	char                       p_sep_by_space;       /*    83     1 */
	char                       n_cs_precedes;        /*    84     1 */
	char                       n_sep_by_space;       /*    85     1 */
	char                       p_sign_posn;          /*    86     1 */
	char                       n_sign_posn;          /*    87     1 */
	char                       int_p_cs_precedes;    /*    88     1 */
	char                       int_p_sep_by_space;   /*    89     1 */
	char                       int_n_cs_precedes;    /*    90     1 */
	char                       int_n_sep_by_space;   /*    91     1 */
	char                       int_p_sign_posn;      /*    92     1 */
	char                       int_n_sign_posn;      /*    93     1 */

	/* size: 96, cachelines: 2, members: 24 */
	/* padding: 2 */
	/* last cacheline: 32 bytes */
};
struct _G_fpos_t {
	__off_t                    __pos;                /*     0     8 */
	__mbstate_t                __state;              /*     8     8 */

	/* size: 16, cachelines: 1, members: 2 */
	/* last cacheline: 16 bytes */
};
class Solver {
public:

	void Solver(class Solver *, const class Solver  &);

	int ()(void) * *           _vptr.Solver;         /*     0     8 */
	void initialise_solution(class Solver *);

protected:

	double                     _y_0;                 /*     8     8 */
	double                     _dt;                  /*    16     8 */
	double                     _t_end;               /*    24     8 */
	class vector<double, std::allocator<double> > _solution; /*    32    24 */
public:

	void Solver(class Solver *);

	void Solver(class Solver *, double, double, double);

	void print_solution(class Solver *);

	class vector<double, std::allocator<double> > get_solution(class Solver *);

	virtual void solve(class Solver *, const class function<double(double, double)>  &);

	virtual void ~Solver(class Solver *, int);

	/* vtable has 1 entries: {
	   [0] = solve((null)), 
	} */
	/* size: 56, cachelines: 1, members: 5 */
	/* last cacheline: 56 bytes */
};
class ImplicitEuler : public Solver {
public:

	/* class Solver              <ancestor>; */      /*     0    56 */
	double Newton(class ImplicitEuler *, const class function<double(double, double)>  &, double, double, double);

	virtual void solve(class ImplicitEuler *, const class function<double(double, double)>  &);

	void ImplicitEuler(class ImplicitEuler *, double, double, double);

	virtual void ~ImplicitEuler(class ImplicitEuler *, int);

	/* vtable has 1 entries: {
	   [0] = solve((null)), 
	} */
	/* size: 56, cachelines: 1, members: 1 */
	/* last cacheline: 56 bytes */

	/* BRAIN FART ALERT! 56 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 448 bits */
};
class ExplicitEuler : public Solver {
public:

	/* class Solver              <ancestor>; */      /*     0    56 */
	virtual void solve(class ExplicitEuler *, const class function<double(double, double)>  &);

	void ExplicitEuler(class ExplicitEuler *, double, double, double);

	virtual void ~ExplicitEuler(class ExplicitEuler *, int);

	/* vtable has 1 entries: {
	   [0] = solve((null)), 
	} */
	/* size: 56, cachelines: 1, members: 1 */
	/* last cacheline: 56 bytes */

	/* BRAIN FART ALERT! 56 bytes != 0 (member bytes) + 0 (member bits) + 0 (byte holes) + 0 (bit holes), diff = 448 bits */
};
